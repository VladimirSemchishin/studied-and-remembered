### Введение. Несколько слов о NoSQL

Вы уже знаете, что реляционные БД — это набор таблиц и связей между ними. Такие БД подходят не для всех задач. Например, данные без структуры невозможно уложить в таблицу. В итоге разработчики создали для нереляционных моделей данных NoSQL (not only SQL) БД.

Различия реляционных и нереляционных БД

|                        | Реляционные                                                  | Нереляционные                                                |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Способ хранения данных | В таблицах                                                   | По-разному: как документы, как граф из вершин и ребер, как пары «ключ-значение» и т. д. |
| Структура данных       | Жесткая: у каждого объекта одни и те же поля                 | Жестких требований нет — у объектов могут быть разные поля   |
| Добавление полей       | Потребует изменить структуру таблицы и все объекты в ней     | Не потребует ничего менять — можно добавить поля только к новым объектам |
| ACID*                  | Соответствуют требованиям ACID                               | ACID могут жертвовать, чтобы увеличить скорость работы или горизонтально масштабировать БД |
| Масштабирование        | В основном вертикальное: с помощью увеличения мощности серверов | Вертикальное и горизонтальное: с помощью увеличения мощности серверов или их количества |
| Язык запросов          | SQL или близкие к нему диалекты                              | Разные синтаксисы. Например, в MongoDB используются запросы в формате JSON |

> Требования ACID — это:
>
> - **Atomicity** — атомарность: транзакция не выполняется, пока не выполнены все ее части;
> - **Consistency** — целостность: когда транзакция завершилась, данные соответствуют схеме БД, а все реплики базы синхронизированы;
> - **Isolation** — изолированность: параллельные транзакции выполняются отдельно друг от друга;
> - **Durability** — надежность: способность восстанавливаться до последнего сохраненного состояния после сбоя.

> На этом и следующих уроках вы познакомитесь с документо-ориентированной БД MongoDB и тем, как с ней работать в Yandex Cloud.

MongoDB — это популярная NoSQL БД, в которой данные хранятся не в строках таблиц, а в **документах**. Один объект — один документ. Структура каждого документа подобна структуре JSON (JavaScript Object Notation).

Так может выглядеть документ из базы данных поликлиники с медицинскими картами пациентов:

`{
  "Имя":"Сергей",
  "Фамилия":"Шишкин",
  "Дата рождения":"02.12.1961",
  "Номер медицинской карты":23264,
  "Посещения врача":[
    {
      "Дата":"24.02.2021",
      "Врач":"Сидорова О.С.",
      "Анамнез":"...",
      "Назначенные обследования":"Общий анализ крови",
      "Диагноз":"ОРВИ",
      "Лечение":"Теплый чай с медом перорально до 12 раз в сутки"
    },
    {
      "Дата":"05.03.2021",
      "Врач":"Сидорова О.С.",
      "Анамнез":"...",
      "Назначенные обследования":"",
      "Диагноз":"Здоров"
    }
  ]
}`

В отличие от строк в реляционных БД, документы:

- позволяют сохранять объекты со сложной структурой, которая может изменяться;
- могут отличаться друг от друга размером и полями.

Высокоуровнево документы состоят из пар **«ключ - значение»**. В примере с медицинской картой `имя` — это ключ, а `Сергей` — его значение. Значениями могут быть числа, строки, аудиофайлы, изображения, массивы или другие объекты, даже сложные.

Однотипные документы объединяются в **коллекции** — аналог таблиц в реляционных БД. Например, в БД поликлиники могут входить коллекции «Медицинские карты пациентов», «Результаты лабораторной диагностики» и «Листы нетрудоспособности».

MongoDB подойдет, если необходимо:

- **Управлять большим объемом данных с заранее неизвестной структурой** (каталоги товаров, пользовательские профили, системы управления контентом).

  > ​      Пример: интернет-магазин, где продается множество товаров с разными характеристиками. Чтобы выставить товар на сайт, контент-менеджер выбирает характеристики и их значения из набора. Менеджер также может добавить или удалить любое поле и установленные для него значения.

- **Горизонтально масштабироваться.**

  ​      Пример: создание национальной БД медицинских карт. Реляционная БД здесь — не лучшее решение: ее горизонтальное масштабирование сопряжено с трудностями и плохо автоматизируется.

### Создание кластера MongoDB

**Создание кластера базы данных**

Выберите в консоли управления Yandex Cloud каталог для кластера БД. На дашборде каталога откройте раздел **Managed Service for MongoDB**. В открывшемся окне нажмите кнопку **Создать кластер**.

Установите основные настройки кластера. Для этого урока создайте кластер с минимальной конфигурацией: тип хоста `burstable`, класс `b2.nano`, стандартное сетевое хранилище размером 10 ГБ. Откройте публичный доступ к хосту и задайте пароль пользователя БД. Остальные значения оставьте по умолчанию.

## Подключение к базе данных

В сервисе управляемых БД MongoDB к хостам можно подключаться через интернет или с виртуальных машин в той же сети. Порт для подключения — `27018`.

Для подключения через интернет хосты кластера должны находиться в публичном доступе. Подключаться можно только через зашифрованное соединение.

Обратите внимание: если публичный доступ настроен только для некоторых хостов в кластере, то при автоматической смене основной реплики она может оказаться недоступной из интернета.

Если к хосту нет публичного доступа и вы подключаетесь к нему с виртуальных машин Yandex Cloud, то зашифрованное соединение необязательно.

Подключитесь к созданной БД из интернета. Используйте SSL-сертификат, который вы подготовили на одной из предыдущих практических работ, или команду (для Ubuntu):

`sudo mkdir -p /usr/local/share/ca-certificates/Yandex && \
sudo wget "https://storage.yandexcloud.net/cloud-certs/CA.pem" -O /usr/local/share/ca-certificates/Yandex/YandexInternalRootCA.crt`

Если всё пройдет успешно — вы получите сообщение операционной системы о том, что сертификат сохранён.

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/24/02.png)

Установите утилиту [MongoDB Shell](https://www.mongodb.com/docs/mongodb-shell/install/):

`sudo apt-get install -y mongodb-mongosh`

> **НО** у меня выдало ошибку: 
>
> `Reading package lists... Done
> Building dependency tree... Done
> Reading state information... Done
> E: Unable to locate package mongodb-mongosh`
>
> Решение нашел такое: 
>
> ```
> wget -qO - https://www.mongodb.org/static/pgp/server-6.0.asc |  gpg --dearmor | sudo tee /usr/share/keyrings/mongodb.gpg > /dev/null 
> echo "deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb.gpg ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/6.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-6.0.list
> sudo apt update
> sudo apt install mongodb-org
> ```

Подключиться к кластеру из командной строки:

`mongosh --norc \
        --tls \
        --tlsCAFile /home/<домашняя директория>/.mongodb/root.crt \
        --host '<FQDN хоста MongoDB>:27018' \
        --username <имя пользователя БД> \
        --password <пароль пользователя БД> \
        <имя БД>`

При успешном подключении вы получите сообщение:![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/24/041.png)

Создадим в БД коллекцию users. Предположим, в ней содержится информация о пользователях вашего приложения.

`db.createCollection("users")`

Загрузим в коллекцию тестовые данные с помощью методов добавления одного документа `db.insertOne(...)` и сразу нескольких `db.insertMany(...)`.

Сначала добавим один документ (данные одного пользователя). 

`db.users.insertOne({firstName: "Adam", lastName: "Smith", age: 37, email: "adam.smith@test.com"});`

Дополним коллекцию данными еще двух пользователей.

`db.users.insertMany( [
      {firstName: "Viktoria", lastName: "Holmes", age: 73, email: "viktoria.holmes@test.com", phone: "737772727"},
      {firstName: "Tina", lastName: "Anders", age: 29, email: "tina.anders@test.com", children: [{firstName: "Sam", lastName: "Anders"},{firstName: "Anna", lastName: "Anders"}]}
   ] );`

Обратите внимание, что документы в коллекции `users` содержат разный набор данных. С помощью MongoDB мы можем работать с данными, структура которых частично не совпадает.

Теперь посмотрим на содержимое коллекции с помощью команды `db.users.find()`. Результат показывает, что все данные успешно добавлены:

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/24/07.png)

Проверим, есть ли среди пользователей те, кому больше 37 лет. Сделаем запрос к БД с помощью метода `find`.

`db.users.find({age: {$gt: 37}});`

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/24/08.png)

Подробности о методах работы с данными в MongoDB вы найдете в [документации](https://docs.mongodb.com/manual/reference/method/).

### Шардирование

**Шардирование** — это горизонтальное масштабирование данных, при котором данные разбиваются на **шарды** (т. е. части) и размещаются на разных хостах кластера. Нагрузка на БД при этом распределяется по хостам, что позволяет добиться большей производительности системы, чем если бы она была расположена на одном мощном сервере. Это особенно важно, если данных или запросов к ним очень много.

***Плюсы*** шардирования в том, что оно позволяет:

- **Обойти технические ограничения.** 

  > Если БД работает на пределе производительности — можно разбить её на части и распределить запросы на чтение между ними.

- **Ускорить доступ к данным для пользователей из конкретного региона.** 

  > Например, международные соцсети могут хранить контент на русском языке на серверах ближе к России.

- **Выполнить юридические требования.** 

  > Например, хранить конфиденциальные данные на шарде, публичный доступ к которому отключен.

- **Повысить доступность.** 

  > Если БД находится на одном нешардированном хосте, то его выход из строя приведет к потере всех данных. Если же БД шардирована, то при отказе одного шарда все данные на других остаются доступными.

  >   Для шардов можно дополнительно настроить репликацию. Так вы обойдетесь без потерь, если сервер выйдет из строя. А размещение реплик шарда в разных зонах доступности даст вам отказоустойчивую систему.

- **Ускорить запросы.** 

  > Они могут выполняться медленнее из-за того, что конкурируют за ресурсы сервера. Шардирование устраняет конкуренцию, исполняя запросы параллельно на разных серверах.

Каким бы замечательным ни было шардирование, у него есть и недостатки:

- Правильно **шардировать данные**, т. е. разбить их на части — **непростая задача**. Если вы сделаете это неверно, то мощности серверов будут использоваться нерационально. Например, потребуется много межсерверных запросов.
- Из-за несбалансированного распределения данных между шардами **появляются горячие точки** — разделы БД, к которым идет намного больше обращений по сравнению с остальными. Запросы к горячим точкам обрабатываются заметно медленнее.

**Шардирование в MongoDB**

В MongoDB шардирование коллекций поддерживается по умолчанию — части коллекций MongoDB размещаются на разных хостах кластера. 

На какой шард попадет фрагмент данных, определяет **ключ шардирования**.

От выбора ключа зависит удобство работы с коллекцией и производительность. 

Следует логично распределить данные коллекции по шардам. Данные на шардах не должны быть связаны между собой.

Шардировать данные имеет смысл, если:

- Данных много (коллекция больше 200 ГБ).
- Данные неоднородны и четко делятся на примерно одинаковые по объему данных категории.
- Требования к скорости чтения и записи данных высоки. Шардирование распределит нагрузку по хостам, чтобы обойти технические ограничения.

Шардирование доступно для кластеров MongoDB с версией не ниже 4.0. Оно происходит с автоматическим созданием служебных хостов **mongos** (для маршрутизации запросов пользователей) и **mongocfg** (для хранения конфигурации шардов), которые тарифицируются отдельно от основных хостов БД.

Сервис поддерживает две основные стратегии шардирования данных: 

- по хешу (ключ шардирования на базе хеша); 
- по диапазону значений (ranged sharding).

Отменить шардирование кластера невозможно. Чтобы воссоздать кластер до шардирования, придется сделать его резервную копию, а затем из копии создать новый кластер.

Чтобы повысить доступность, составляйте каждый шард из трёх или более хостов БД.

### Особенности сервиса управляемых баз данных MongoDB

**Ответственность сервиса**

> Как вы могли увидеть, в работе с различными сервисами управляемых БД в облаке есть много общего. При этом, каждый из сервисов имеет свои особенности, обусловленные как самой СУБД, так и спецификой её реализации в облаке.

Как и в случае реляционных БД, сервис управляемых баз данных MongoDB выполняет задачи, связанные с администрированием инфраструктуры:

- при создании кластера выделяет ресурсы, устанавливает СУБД и создает БД;
- обновляет программное обеспечение;
- автоматически создает резервные копии БД;
- предоставляет инструменты мониторинга хостов и БД;
- обеспечивает репликацию данных между хостами;
- при аварии автоматически переключает нагрузку на резервную реплику.

Вы можете выбирать любые клиенты для MongoDB. Yandex Managed Service for MongoDB гарантирует работу интерактивного интерфейса the mongo Shell, а также драйверов для Python и Java.

**Обновление базы данных**

Сервис поддерживает мажорные версии MongoDB 4.2, 4.4 и 5.0. Переходить на новую мажорную версию следует вручную. При выходе новых минорных версий MongoDB кластеры обновляется автоматически. Владельцы кластеров получают оповещение о сроках работ и доступности БД.

Когда разработчики перестают поддерживать версию MongoDB, создание хостов с ней становится невозможным, а кластеры автоматически обновляются до ближайшей поддерживаемой версии. Это происходит через семь дней после оповещения для минорных версий и через месяц для мажорных.

**Резервное копирование**

Сервис создает резервные копии БД автоматически, а также позволяет делать это вручную. Резервные копии сохраняются в специальном хранилище в сжатом виде. Вы не платите за их хранение, пока размер БД и всех резервных копий не превышает размера хранилища, который вы выбрали при создании кластера.

По умолчанию автоматическое резервное копирование выполняется раз в день с 01:00 по 05:00 по московскому времени, а резервные копии хранятся неделю. Время начала резервного копирования и срок хранения резервных копий (от 7 до 35 дней) можно установить при создании или изменении кластера.

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/26/01.png)

Автоматически созданные копии удаляются, когда истекает срок хранения. Копии, созданные вручную, хранятся бессрочно.

Из резервной копии можно восстановить как существующий, так и удаленный кластер. Средняя скорость восстановления — 10 МБ/с.

Для версий MongoDB 4.2 и выше сервис поддерживает технологию **point-in-time recovery** (восстановление состояния кластера на заданный момент). Вы можете восстановить кластер в состояние на любой момент времени после создания самой старой полной резервной копии. Это достигается за счет дополнения данных выбранной резервной копии записями из архивируемого журнала операций.

Point-in-time recovery работает только для кластеров с выключенным шардированием.

**Мониторинг и логи**

Сервис отслеживает и выводит на дашборд следующие метрики: общий объём данных, размер журнала операций, место на диске, число подключений к базе, сессий и операций, лаг репликации и пр. Подробнее о мониторинге Yandex Managed Service for MongoDB вы можете узнать [в документации](https://cloud.yandex.ru/docs/managed-mongodb/operations/monitoring).

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/26/02.png)

Кроме того, сервис ведет запись логов событий.

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/26/03.png)

**Репликация и отказоустойчивость**

Сервис управляемых БД MongoDB по умолчанию реплицирует данные, т. е. копирует их на несколько хостов. Если в кластере больше одного активного хоста, из них автоматически выбирается главный — **первичная реплика**. Этот хост обрабатывает все запросы на запись.

![image](https://pictures.s3.yandex.net/resources/4_8_1626202222.png)

Первичная реплика выбирается автоматически, если в кластере работоспособно больше половины хостов. По этой причине кластер из двух хостов не обеспечивает отказоустойчивости. Если первый хост отказал, второй не сможет назначить сам себя первичной репликой и будет обрабатывать только операции чтения.

Кластер из трёх хостов продолжит обрабатывать операции записи при потере одного хоста. Кластер из четырёх хостов также может потерять только один хост: при потере второго оставшихся хостов не хватит, чтобы автоматически выбрать первичную реплику. Поэтому в MongoDB лучше разворачивать кластеры с нечетным числом хостов.

![image](https://pictures.s3.yandex.net/resources/5_7_1626202226.png)

## Лимиты и тарификация

[Лимиты](https://cloud.yandex.ru/docs/managed-mongodb/concepts/limits) сервиса таковы.

В кластере БД MongoDB можно создать не более 10 шардов. Шард состоит не более чем из семи хостов. Таким образом, максимальное число хостов в одном кластере не может превышать 70.

Максимальное число одновременных подключений к одному хосту зависит от объёма его оперативной памяти: не более 2048 подключений на каждые 2 ГБ.

Максимальный объём данных на хосте — 605 ГБ при использовании сетевого хранилища или 600 ГБ при использовании локального хранилища.

MongoDB тарифицируется по тем же принципам, что и управляемые реляционные БД. Об особенностях тарификации этого сервиса вы можете узнать [из документации](https://cloud.yandex.ru/docs/managed-mongodb/pricing#prices).

> **Проверьте себя**
>
> Вы используете для своего приложения управляемую базу данных MongoDB. Кластер состоит из одного хоста `s2.large` (12 vCPU, 48 ГБ) с быстрым сетевым хранилищем объёмом 50 ГБ.
>
> С учётом растущей нагрузки на кластер и далеко идущих планов по развитию приложения вы решаете разбить БД на два шарда, понизив при этом класс хостов до `s2.medium` (8 vCPU, 32 ГБ) и увеличив объём хранилища до 100 ГБ, а также сделать БД отказоустойчивой.
>
> Сколько хостов в кластере вам для этого понадобится?
>
> - 2 (два хоста для шардов)
> - 3 (два хоста для шардов и еще один для реплики)
> - 4 (два хоста для шардов и еще по одной реплике на каждый шард)
> - 5 (два хоста для шардов и еще три реплики, потому что хостов должно быть нечетное число)
> - 6 (два хоста для шардов и еще по две реплики на каждый шард)
>
> Сколько примерно времени займет восстановление кластера размером 10 ГБ из резервной копии?
>
> - 1,5 минуты
> - 17 минут
> - 34 минуты
>
> 
>
> 
>
> **ОТВЕТ:** 5,17