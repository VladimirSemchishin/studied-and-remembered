# Краткий обзор YDB

> На предыдущих уроках мы рассматривали и классические реляционные, и NoSQL базы данных. Каждый из этих типов БД имеет свои сильные стороны и области применения.

> Классические реляционные БД хорошо подходят для сценариев работы, связанных с обработкой транзакций (online transaction processing, OLTP). Они обеспечивают выполнение транзакционных [требований ACID](https://practicum.yandex.ru/trainer/ycloud/lesson/fba94218-11e7-446b-b5ac-8ef5a606766b/), что особенно важно для систем, связанных с финансами или обработкой заказов. Сложности возникают, когда данных становится много, поскольку эти БД плохо масштабируются.

> Базы данных NoSQL изначально создавались как распределённые системы. Поэтому они легко масштабируются и обеспечивают высокую доступность данных. Однако это имеет свою цену: требования ACID, в частности целостность и надёжность, в этих БД выполняются не полностью.

Стремление объединить преимущества классических реляционных и NoSQL баз данных привели к созданию нового типа СУБД, который назвали **NewSQL** или **Distributed SQL**. 

Это распределённые реляционные базы данных, которые одновременно обеспечивают строгое выполнение требований ACID и хорошее горизонтальное масштабирование.

К таким БД относится и YDB, которая была разработана компанией Yandex для решения внутренних задач, а с 2019 года стала доступна для внешних пользователей. Она спроектирована с учетом высоких требований к производительности (миллионы запросов в секунду) и объёму данных (сотни петабайт). YDB используется для хранения данных сервисов Yandex Cloud, а также во многих сервисах Yandex (например, Яндекс Go, Яндекс Погода, Яндекс Маркет, Авто.ру, Кинопоиск и других).

**YDB обеспечивает:**

- строгую консистентность с возможностью ослабления для увеличения производительности;
- высокую доступность БД с автоматической обработкой отказов вычислительных узлов и дата-центров;
- автоматическую репликацию БД;
- автоматическое партиционирование данных при увеличении их объёма или росте нагрузки.

YDB поддерживает высокопроизводительные распределенные ACID-транзакции, которые могут затрагивать несколько записей из разных таблиц. При этом обеспечивается самый строгий уровень изоляции транзакций — **serializable**. Если возникает необходимость увеличить производительность БД или уменьшить задержки, можно ослабить уровень изоляции для операций чтения.

YDB основана на реляционной модели данных и оперирует таблицами с предопределённой схемой. Таблицы в YDB всегда имеют один или несколько столбцов, являющихся первичным ключом.

Для удобной организации хранения таблиц в YDB используется дерево папок (директорий), в которых находятся таблицы и другие сущности БД. По аналогии с обычными файловыми системами в одной директории могут быть несколько поддиректорий и несколько таблиц. Имена у сущностей внутри одной директории должны быть уникальны.

YDB может использоваться в двух режимах: 

- **dedicated** 

  В **dedicated** режиме для БД выделяются отдельные хосты. Вы самостоятельно задаете число и класс хостов, параметры хранилища данных и облачных сетей. Иными словами, в этом режиме вы работаете с YDB как с сервисом управляемой БД.

  > В этом режиме вам будет нужно самостоятельно отслеживать, насколько выделенные вычислительные ресурсы соответствуют нагрузке на БД. Если их будет недостаточно, то скорость обработки запросов будет снижаться вплоть до отказа в обслуживании. Чтобы избежать этого, понадобится самостоятельно наращивать мощности (увеличивать число и/или повышать класс хостов, увеличивать объём хранилища данных).
  >
  > Тарификация в dedicated режиме основана на тех же принципах, что и в сервисах управляемых БД. Вы платите за:
  >
  > - время работы вычислительных ресурсов (в зависимости от числа и класса используемых хостов);
  > - хранилище данных (с учетом типа и размера групп хранения);
  > - хранение резервных копий БД в объектном хранилище;
  > - трафик из Yandex Cloud в интернет.

- **serverless**.

  В **serverless**, или бессерверном, режиме БД разворачивается без создания отдельных хостов. Все необходимые для работы БД ресурсы (вычислительные мощности, хранилище данных, сети) предоставляются сервисом автоматически и так же автоматически масштабируются в зависимости от нагрузки.

  > Этот режим подходит для небольших проектов, когда отдельный сервер не нужен, или для задач с неравномерной и плохо прогнозируемой нагрузкой. При его использовании вы платите за операции с БД (чтение и запись данных), а также за хранение данных и резервных копий.
  >
  > С работой YDB в бессерверном режиме вы подробно познакомитесь в курсе «Serverless».

Для работы с данными в YDB используется декларативный язык запросов YQL, являющийся диалектом SQL. 

В бессерверном режиме также доступен Document API — HTTP API, совместимый с Amazon DynamoDB. С его помощью можно выполнять операции над документными таблицами (на уровне приложений для работы с такими таблицами используется формат JSON).

YDB является альтернативой имеющимся решениям в следующих случаях:

- при использовании NoSQL систем, когда нужна строгая консистентность данных;
- при использовании NoSQL систем, когда требуется транзакционное изменение данных, хранящихся в разных строках одной или нескольких таблиц;
- в системах, где нужно обрабатывать и хранить большой объём данных с возможностью бесконечного масштабирования;
- в системах с незначительной нагрузкой, когда держать для БД отдельный хост нерационально с финансовой точки зрения (в этом случае YDB используется в бессерверном режиме);
- в системах с плохо предсказуемой или сезонно меняющейся нагрузкой;
- в системах, где важно распределять нагрузку между инстансами реляционной БД.

Подробный видеообзор YDB [вы можете посмотреть](https://youtu.be/o0-IpbkQKjc) на YouTube-канале Yandex Cloud.

Далее в этой теме вы продолжите знакомство с тем, как YDB используется в dedicated режиме, и потренируетеcь работать с ней на практике.

# Модель и схема данных в YDB, запросы и транзакции

> В этом уроке мы более подробно разберем, как в YDB организованы данные, каких типов они могут быть, а также познакомимся с поддерживаемыми режимами транзакций.

## Модель и схема данных

YDB основана на **реляционной модели** данных. Это означает, что данные организованы в виде связанных друг с другом таблиц, которые состоят из столбцов и строк.

- **Таблицы** хранят записанную в БД информацию об объектах или сущностях. 

- **В столбцах** таблицы записываются определённые типы данных, 
- а **в ячейках** — значения. 
- Каждая **строка таблицы** представляет собой набор связанных значений, относящихся к одному объекту или сущности.

Таблица YDB всегда имеет один или несколько столбцов, являющихся первичным ключом (primary key). Первичный ключ представляет собой уникальный идентификатор строки, то есть для одного значения ключа может быть не больше одной строки. Допускаются таблицы, состоящие только из ключевых столбцов.

> Таблицы без первичного ключа создавать нельзя!

В YDB таблицы всегда упорядочены по ключу. Это приводит к тому, что точечное чтение по ключу и диапазонные запросы по ключу или префиксу ключа фактически выполняются с использованием индекса, то есть с высокой эффективностью.

**Схема данных** определяет имена (names) столбцов таблицы и то, какие типы данных (types) в них хранятся. Пример схемы данных приведен на рисунке.

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/33/01.png)

Здесь изображена схема таблицы `series`, которая состоит из четырех столбцов с именами `series_id`, `release_date`, `series_info` и `title`. Первый столбец имеет тип данных `Uint64`, второй — `Date`, а последние два — `Utf8`. В качестве первичного ключа (PK) объявлен столбец `series_id`.

**Партиционирование таблиц**

Первичный ключ также используется в YDB для разбиения таблиц на несколько частей - **партиционирование**  

Каждая часть — **партиция** — включает отдельный диапазон первичных ключей, то есть диапазоны ключей, обслуживаемых разными партициями, не пересекаются.

Партиции одной таблицы могут располагаться на разных, в том числе расположенных в разных локациях, хостах распределённой БД. Они могут перемещаться между хостами независимо друг от друга для перебалансировки данных и равномерного распределения нагрузки, а также для поддержания работоспособности партиции при отказах серверов или сетевых сбоях.

Если данных немного, таблица может состоять из одной партиции. YDB автоматически разобьёт партицию на две части, когда объём данных в ней или нагрузка увеличатся сверх определенного предела. Включение и выключение автоматического разделения можно настроить для каждой таблицы БД индивидуально.

Помимо автоматического разделения таблиц на партиции YDB дает возможность создавать пустые таблицы с предопределённым количеством партиций. Для этого нужно либо задать границы диапазонов ключей вручную, либо указать, что таблица разделяется на заданное число партиций равномерно. В последнем случае границы диапазонов будут созданы по первой компоненте первичного ключа, которая должна быть целым числом.

## Типы данных

Тип данных определяет множество значений, которые эти данные могут принимать, и то, какие операции можно выполнять со значениями. Например, данные логического типа (Bool) могут принимать значения true и false, и с ними можно выполнять логические операции И, ИЛИ, НЕ, ИСКЛЮЧАЮЩЕЕ ИЛИ, а также операции сравнения.

Для работы с данными в YDB применяется декларативный язык запросов YQL (Yandex Query Language). Соответственно, в YDB можно использовать те типы данных, которые есть в YQL. Некоторые из типов данных YQL поддерживаются в YDB с ограничениями: они могут использоваться только в вычислениях, но не могут быть типом столбца или первичным ключом.

**Элементарными или примитивными типами** данных называют такие, для которых значения нельзя разделить на несколько значений другого типа. К таким типам данных относят, например:

- логический – `Bool`;
- числовой – `IntXX`, `UintXX`, `Float`, `Double` (целые знаковые и беззнаковые числа, где XX показывает разрядность в битах; числа с плавающей точкой; числа двойной точности);
- строковый – `String`, `Utf8`, `Json`, `Uuid` (произвольные бинарные данные, текст, форматы данных);
- временной – `Date`, `Datetime`, `Timestamp`, `Interval` (дата, дата и время с точностью до секунд, временная отметка и интервал с точностью до микросекунд).

**Композитные типы данных, или контейнеры**, состоят из данных других элементарных или композитных типов. Такие типы данных в YQL включают:

- список (`List`) – последовательность из 0 и более элементов одного типа. Количество элементов не фиксировано.
- кортеж (`Tuple`) – упорядоченный набор из 0 и более элементов произвольных типов. Количество элементов фиксировано.
- структуру (`Struct`) – именованный неупорядоченный набор из 0 или более элементов произвольных типов. Количество элементов фиксировано.
- словарь (`Dict`) – набор пар «ключ-значение». Все значения ключей уникальны. Все ключи имеют один и тот же тип, как и значения. Количество элементов не фиксировано.
- опциональный тип (`Optional`) – последовательность из 0 или 1 элементов некоторого типа. Случай, когда в последовательности 0 элементов, изображается как NULL.
- вариант (`Variant`) – подвид кортежа или структуры, в котором заполнен ровно один элемент.

Все столбцы, в том числе столбцы с первичным ключом, также могут содержать специальное значение `NULL`, которое используется, чтобы обозначить отсутствие значения.

С полным перечнем типов данных, а также возможных операций над ними вы можете познакомиться в [документации](https://ydb.tech/ru/docs/yql/reference/types/).

## Запросы и транзакции

Основным средством добавления, обновления и удаления строк данных, извлечения наборов данных, а также управления работой БД в YDB является декларативный язык запросов YQL. Для выполнения YQL запросов можно использовать консоль управления Yandex Cloud в браузере, консольный клиент для командной строки, а также SDK для различных языков программирования, которые позволяют встраивать запросы в приложения.

**Запрос** – это команда на выполнение операции чтения или записи данных в БД. Например, запрос на чтение всех данных из таблицы будет выглядеть так:

`SELECT * FROM <имя таблицы>`

> В одном из следующих практических уроков вы потренируетесь выполнять различные запросы к базе данных YDB.

**Транзакция** – это несколько связанных запросов к БД, то есть последовательность операций чтения и записи данных, представляющая собой единую логическую задачу. Например, если вы перечисляете деньги с одного счёта на другой, то с точки зрения работы с БД транзакция будет включать:

- чтение данных о состоянии первого счёта, чтобы проверить достаточно ли на нём средств;
- уменьшение значения баланса этого счёта на сумму перевода;
- чтение данных о состоянии второго счёта;
- увеличение значения баланса этого счёта на сумму перевода.

Транзакция будет выполнена только в том случае, если будут успешно завершены все операции, которые она включает.

Транзакции в YDB по умолчанию выполняются в режиме **Serializable**. Это самый строгий уровень изоляции транзакций. Иными словами, в этом режиме гарантируется, что каждая транзакция полностью независима от других.

Если требования к консистентности или свежести читаемых данных могут быть ослаблены (например для повышения производительности БД, увеличения пропускной способности или уменьшения задержек), то пользователь может использовать режимы с менее строгими уровнями изоляции транзакций:

- **Online Read-Only** – каждая из операций чтения в транзакции получает последние данные из имеющихся на момент выполнения. Консистентность полученных данных определяется настройкой `allow_inconsistent_reads`;
- **Stale Read Only** – операции чтения данных возвращают результаты с возможным отставанием от актуальных (отставание составляет доли секунды). Для каждой отдельной операции чтения данные консистентны, но для разных операций чтения консистентность не гарантируется.

Поскольку таблицы в YDB могут быть партицированы, а отдельные партиции – храниться на разных шардах, YDB поддерживает распределённые транзакции, то есть транзакции, которые затрагивают более одного шарда одной или нескольких таблиц.

> А теперь давайте посмотрим, как YDB работает на практике.

# Создание базы данных

В этой практической работе вы создадите БД YDB в dedicated режиме, научитесь подключаться к ней и добавлять данные из тестового приложения.

## Создание базы данных

1. На стартовой странице консоли управления перейдите в каталог, в котором будете создавать БД, выберите в списке сервисов **База данных YDB** и нажмите кнопку **Создать ресурс**.

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/34/01.png)

2. В открывшемся окне выберите тип БД **dedicated**. Появившийся интерфейс создания новой БД практически идентичен уже знакомым вам интерфейсам создания кластеров управляемых БД.

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/34/02.png)

3. Выберите для вашей БД имя, назначьте необходимые вычислительные ресурсы (для этой и следующих практических работ достаточно одного хоста конфигурации `medium`), тип и количество групп хранения (достаточно одной группы).

​     Группа хранения – это массив независимых дисковых накопителей, объединённых по сети в единый логический элемент. В YDB такой массив состоит из 9 дисков, расположенных по три в каждой из трёх зон доступности. Такая конфигурация обеспечивает устойчивость при одновременном отказе одной из зон и отказе диска в другой зоне. Стандартный размер группы хранения — 100 ГБ.

4. Выберите облачную сеть и подсети для работы с БД. Вы можете оставить сеть по умолчанию или выбрать ту, которую создали на предыдущем курсе. БД будет доступна для всех виртуальных машин, которые подключены к той же облачной сети.

Также выберите опцию присвоения публичного IP-адреса, чтобы иметь возможность подключаться к БД из интернета.

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/34/03.png)

5. Нажмите кнопку **Создать базу данных**.

​     Создание БД занимает несколько минут. Когда статус БД изменится с `Provisioning` на `Running`, она готова к работе.

6. Кликнув на созданную БД в консоли управления, вы перейдёте на вкладку **Обзор**.

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/34/04.png)![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/34/05.png)

​       В разделе **Соединение** на этой странице приведена информация, которая вам понадобится для подключения к БД:

- **Эндпоинт** — точка подключения с указанием протокола, представляющая собой в данном случае адрес, на который посылаются сообщения;

- **Размещение базы данных** — полный путь к БД.

  Примеры подключений из командной строки и приложений вы можете посмотреть, нажав на кнопку **Подключиться**.

## Подключение к базе данных и запуск тестового приложения

> Подключение CLI
>
> *Интерфейс командной строки Yandex Cloud (CLI)* — скачиваемое программное обеспечение для управления вашими облачными ресурсами через командную строку.
>
> Установка: `curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash`
>
> (Скрипт дополнит переменную `PATH` только если его запустить в командных оболочках `bash` или `zsh`. Если вы запустили скрипт в другой оболочке, добавьте путь до CLI в переменную `PATH` самостоятел)
>
> Создание профиля:
>
> 1. Получите OAuth-токен в сервисе Яндекс.OAuth.  по [ссылке](https://oauth.yandex.ru/authorize?response_type=token&client_id=1a6990aa636648e9b2ef855fa7bec2fb) (y0_AgAAAABILCSCAATuwQAAAADeFOMS7UKvjVnQThOntRdGs_Ez3WIdBfQ)
> 2. Создать профиль: `yc init`
> 3. Проверить: `yc config list`



В этой части практической работы вы подключитесь к БД и запустите тестовое приложение, чтобы создать в ней несколько таблиц с данными о популярных сериалах.

7. Для того, чтобы выполнить эту задачу, вам понадобится сервисный аккаунт с ролями `viewer` и `editor`. Перейдите в дашборд каталога и выберите вкладку **Сервисные аккаунты**. Создайте сервисный аккаунт, назначив для него указанные роли. Сохраните идентификатор этого аккаунта.

8. Вы можете запускать тестовое приложение со своего компьютера или с виртуальной машины в Yandex Cloud. В данном примере используется OC Ubuntu и приложение на Python.

> Если при создании БД вы не присвоили ей публичный IP-адрес, то подключиться к ней вы сможете только с виртуальной машины, расположенной в той же облачной сети.

Для запуска приложения нужно склонировать на свою машину репозиторий YDB Python SDK, из которого оно будет вызываться, а также установить библиотеки `ydb`, `iso8601` и `yandexcloud`. Воспользуйтесь для этого следующими командами:

`git clone https://github.com/yandex-cloud/ydb-python-sdk.git
sudo pip3 install iso8601 ydb yandexcloud`

9. Создайте авторизованный ключ для вашего сервисного аккаунта и сохраните его в файл с помощью интерфейса командной строки Yandex Cloud.

`mkdir ~/.ydb`

`yc iam key create \`
 `--folder-id <идентификатор каталога> \
  --service-account-name <имя сервисного аккаунта> \
  --output ~/.ydb/sa_name.json`

> **НО** --folder-id <идентификатор каталога> , здесь нужно ввести адрес папки (каталога) где хранятся сервисные аккаунты, вот он, рядом с Active, ну а имя это имя сервисного аккаунта![image-20230328073556491](/home/smvn/snap/typora/76/.config/Typora/typora-user-images/image-20230328073556491.png)

10. Получите SSL-сертификат:

    `wget "https://storage.yandexcloud.net/cloud-certs/CA.pem" \
      -O ~/.ydb/CA.pem`

    Установите переменную окружения `YDB_SERVICE_ACCOUNT_KEY_FILE_CREDENTIALS` и переменную окружения с SSL-сертификатом.

    `export YDB_SERVICE_ACCOUNT_KEY_FILE_CREDENTIALS=~/.ydb/sa_name.json
    export YDB_SSL_ROOT_CERTIFICATES_FILE=~/.ydb/CA.pem`

11. Запустите тестовое приложение `basic_example_v1` из репозитория ydb-python-sdk, указав в качестве параметров подключения значения протокола, эндпоинта и полного пути к БД.

    `cd ./ydb-python-sdk/examples/basic_example_v1
    python3 __main__.py \
    -e <Эндпоинт> \
    -d <Размещение базы данных>`

# YQL и работа с данными

В этом уроке вы освоите базовый набор операций для работы с данными с использованием YQL и консоли управления Yandex.Cloud. Подробная информация о YQL приведена в разделе [Справочник YQL](https://ydb.tech/ru/docs/yql/reference/) в документации.

Чтобы начать, войдите в раздел **Навигация** консоли управления и откройте редактор SQL, нажав на кнопку **SQL-запрос**.

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/35/ydb_4_1.png)

На прошлом уроке мы уже создали в нашей БД три таблицы, содержащие информацию о сериалах IT Crowd и Silicon Valley.

1. Добавим в БД еще одну таблицу с рейтингами эпизодов сериала IT Crowd на IMDb.com.

YQL является диалектом SQL, поэтому многие инструкции в этих языках идентичны.

Для создания таблицы вам понадобится сделать запрос к БД, содержащий инструкцию `CREATE TABLE`. Например, если бы мы хотели создать таблицу seasons (она уже есть в вашей БД), то SQL запрос выглядел бы следующим образом:

`CREATE TABLE seasons
(
    series_id Uint64, 
    season_id Uint64, 
    first_aired Date, 
    last_aired Date, 
    title Utf8, 
        PRIMARY KEY (series_id, season_id)
);`

Обратите внимание, что в пределах директории YDB имена таблиц должны быть уникальны. 

> **Первичный ключ (PRIMARY KEY)** — это столбец или комбинация столбцов, однозначно идентифицирующих каждую строку в таблице. Он может содержать только неповторяющиеся значения. Для таблицы YDB указание первичного ключа обязательно, при этом он может быть только один.
>
> Первичный ключ по сути является первичным индексом, который помогает СУБД быстрее обнаруживать отдельные записи в таблице и сокращает время выполнения запросов. 

Также в таблицу можно добавить один или несколько вторичных индексов. Они служат той же цели, но в отличие от первичного индекса могут содержать повторяющиеся значения. Добавить вторичные индексы можно в любой момент, когда возникнет необходимость, и это не вызовет деградацию производительности БД. Чтобы при создании таблицы добавить в нее вторичный индекс, используется такая конструкция:

`INDEX <имя индекса> GLOBAL ON (<имя столбца1>, <имя столбца2>, ...)`

Вторичный индекс можно добавить и в уже существующую таблицу. Работа БД при этом не прерывается. В отличие от предыдущего случая в существующую таблицу можно добавлять только один вторичный индекс за раз. Делается это с помощью следующей команды:

`ALTER TABLE <имя таблицы> ADD INDEX <имя индекса> GLOBAL ON (<имя столбца>);`

**Задание 1**: создайте таблицу `ratings`, в которой будут содержаться рейтинги всех эпизодов сериала IT Crowd, со столбцами `season_id` (Uint64), `episodes_id` (Uint64), `title` (Utf8), `air_date` (Date) и `imdb_rating` (Uint64) и вторичным индексом `rating_index` по полю `imdb_rating`.

> `CREATE TABLE ratings (
>     season_id Uint64, 
>     episodes_id Uint64, 
>     title Utf8, 
>     air_date Date, 
>     imdb_rating Uint64, 
>         PRIMARY KEY (season_id, episodes_id), 
>         INDEX rating_index GLOBAL ON (imdb_rating)
> );`

2. Добавим в эту таблицу данные. Для вставки данных в YDB помимо обычной SQL инструкции [INSERT](https://ydb.tech/ru/docs/yql/reference/syntax/insert_into) также используются инструкции [REPLACE](https://ydb.tech/ru/docs/yql/reference/syntax/replace_into) и [UPSERT](https://ydb.tech/ru/docs/yql/reference/syntax/upsert_into).

   - При выполнении `INSERT` перед операцией записи выполняется операция чтения данных. Это позволяет убедиться, что уникальность первичного ключа будет соблюдена. 

   - При выполнении инструкций `REPLACE` и `UPSERT` осуществляется слепая запись.

     Инструкции `REPLACE` и `UPSERT` используются для добавления новой или изменения существующей строки по заданному значению первичного ключа. 

     > При операциях записи и изменения данных использование этих инструкций эффективне

     <u>Если</u> при выполнении этих инструкций <u>строка</u> с указанным значением первичного ключа <u>не существует</u>, то она будет создана. 

     <u>Если</u> же такая <u>строка существует</u>, то значения ее столбцов будут заменены на новые. 

     **Отличие** между 

     - **`REPLACE`** 

       устанавливает значения столбцов, не участвующих в операции, в значения по умолчанию

     - **`UPSERT`**  

       значения не участвующих столбцов не меняет.

Одним запросом `REPLACE`, `UPSERT` или `INSERT` можно вставить в таблицу несколько строк.

Например, если бы мы хотели добавить в таблицу `series` те данные, которые в ней сейчас содержатся, то SQL запрос выглядел бы так:

`REPLACE INTO series (series_id, title, release_date, series_info) 
VALUES 
    ( 
        1, 
        "IT Crowd", 
        Date("2006-02-03"), 
        "The IT Crowd is a British sitcom produced by Channel 4, written by Graham Linehan, produced by Ash Atalla and starring Chris O'Dowd, Richard Ayoade, Katherine Parkinson, and Matt Berry."), 
    ( 
        2, 
        "Silicon Valley", 
        Date("2014-04-06"), 
        "Silicon Valley is an American comedy television series created by Mike Judge, John Altschuler and Dave Krinsky. The series focuses on five young men who founded a startup company in Silicon Valley." 
    );`

**Задание 2:** добавьте в таблицу `ratings` данные [из этого файла](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/35/imbd_ratings.txt).

> `REPLACE INTO ratings (season_id, episodes_id, title, air_date, imdb_rating) VALUES    `
>
> ​	`(1, 1, "Yesterday's Jam", Date("2006-02-03"), 76),`
>
> ​	`...`
>
> ​	`(4, 6, "Reynholm vs Reynholm", Date("2010-07-30"), 76); `

3. C помощью SQL запросов можно добавлять и удалять не только строки таблицы, но и столбцы. 

   Для этого используется команда **`ALTER TABLE`** и фразы `ADD COLUMN` и `DROP COLUMN`.

   Например, если вы хотите добавить в таблицу `ratings` столбец `viewed` с данными о том, какие эпизоды сериала вы уже посмотрели, то это можно сделать с помощью следующей команды.

   `ALTER TABLE ratings ADD COLUMN viewed Bool; `

**Задание 3**: Вы решили, что столбец с датой выхода эпизодов в таблице `ratings` не нужен, поскольку эта информация уже содержится в другой таблице. Удалите столбец `air_date` из таблицы `ratings`.

> `ALTER TABLE ratings DROP COLUMN air_date; `

4. Теперь потренируемся извлекать данные из БД. 

   Для этого используется команда **`SELECT`**. В простейшем случае ее синтаксис выглядит так:

   `SELECT <имя столбца1>, <имя столбца2>, ...
   FROM <имя таблицы>;`

   Например, чтобы выбрать всю информацию из таблицы `seasons`, нужно сделать следующий запрос к БД: `SELECT * FROM seasons;`

   Если нужно выбрать из таблицы только те строки, которые удовлетворяют определенному условию, в запросе используют секцию `WHERE`. В этой секции должно находиться выражение, возвращающее логический результат. Обычно оно состоит из логических операций and, or, not и операций сравнения.

   Например, выбрать из таблицы `episodes` только первые эпизоды всех сезонов можно так: 

   `SELECT * FROM episodes
   WHERE episode_id = 1
   ; `

   Запрос `SELECT` извлекает строки без определенного порядка. Чтобы отсортировать полученные данные нужным образом, в этот запрос включают секцию **`ORDER BY`**. В ней указывается список столбцов, которые будут определять порядок сортировки результатов запроса.

Задание 4: получите список самых популярных (с рейтингом не менее 85) эпизодов сериала IT Crowd. При поиске используйте созданный ранее вторичный индекс `rating_index`. Чтобы упорядочить результаты по убыванию рейтинга используйте конструкцию `ORDER BY … DESC`.

> `SELECT 
>     season_id, 
>     episodes_id, 
>     title, 
>     imdb_rating
> FROM ratings VIEW rating_index 
> WHERE 
>     imdb_rating >= 85 
> ORDER BY 
>     imdb_rating DESC
> ; `

5. Для получения обобщённых сведений о содержащихся в таблице данных — например, о числе строк в таблице или среднем значении какого-либо выражения — в запрос `SELECT` включают агрегатные функции и секцию` GROUP BY`. Эта секция используется для агрегации внутри каждого ключа. Ключом является значение одной или более колонок, указанных в `GROUP BY`.

   **Примеры агрегатных функций:**

   `COUNT(*)` — вычисляет число строк в таблице.

   `MAX(expr)` — находит максимум выражения expr по всем строкам.

   `SUM(expr)` — суммирует выражение expr по всем строкам. Тип выражения должен быть числовым.

   `AVG(expr)` — находит среднее значение выражения expr по всем строкам. Тип выражения должен быть числовым или интервалом.

   `SOME(expr)` — возвращает одно произвольное значение выражения по всем строкам.

   Результаты выполнения агрегатной функции выводятся в отдельном столбце. Чтобы задать этому столбцу имя, используют оператор `AS`. Конструкция может выглядеть, например, так:

   `SELECT 
       <имя столбца1>, 
       MAX(<имя столбца2>) AS max_value
   ...
   ;`

Задание 5: Напишите SQL запрос к таблице `episodes`, который выводит данные о числе эпизодов каждого сериала.

> Вам понадобится вычислить число строк для каждого значения столбца `series_id` и сгруппировать результаты по `series_id`.
>
> `SELECT 
>     series_id, 
>     COUNT(*) AS total_episodes 
> FROM episodes 
> GROUP BY 
>     series_id 
> ORDER BY 
>     series_id 
> ; `

Задание 6: Напишите SQL запрос, с помощью которого можно сравнить популярность сезонов сериала IT Crowd.

> Вам понадобится вычислить средний рейтинг эпизодов для каждого сезона и сгруппировать результаты по столбцу `season_id`.
>
> `SELECT 
>     season_id, 
>     AVG (imdb_rating) AS avg_rating
> FROM ratings 
> GROUP BY season_id
> ORDER BY avg_rating DESC;`

1. В реляционной БД таблицы логически связаны друг с другом. С помощью объединений (`JOIN`) можно получить данные из нескольких связанных друг с другом таблиц и представить их в виде одной результирующей таблицы

   Столбцы, по которым выполняется объединение, можно указать одним из двух способов.

   1. После ключевого слова **`USING`**, 

      например `table1 AS a JOIN table2 AS b USING (foo)`. 

      Это более короткий способ записи, удобный для простых случаев. Имена столбцов, по которым происходит объединение таблиц, должны быть одинаковы.

   2. После ключевого слова `ON` 

      `a JOIN b ON a.foo = b.bar`

      Этот способ позволяет использовать разные имена столбцов и указывать дополнительные условия по аналогии с `WHERE`.

Поскольку такие запросы затрагивают столбцы разных таблиц, имена столбцов должны содержать и имя таблицы 

> (то есть, например, не просто `series_id`, а `seasons.series_id`).

В YDB доступны следующие логические **типы объединений**:

- `INNER` 

  > (используется по умолчанию) — строки попадают в результат, только если значение ключевых колонок присутствует в обеих таблицах;

- `FULL`, `LEFT` и `RIGHT` 

  > — при отсутствии значения в обеих или в одной из таблиц, включает строку в результат, но оставляет пустыми (`NULL`) колонки, соответствующие противоположной таблице.

- `LEFT/RIGHT SEMI` 

  > — одна сторона выступает как белый список (whitelist) ключей, её значения недоступны. В результат включаются столбцы только из одной таблицы, декартового произведения не возникает;

- `LEFT/RIGHT ONLY` 

  > — вычитание множеств по ключам (blacklist). Практически эквивалентно добавлению условия `IS NULL` на ключ противоположной стороны в обычном `LEFT/RIGHT`, но, как и в `SEMI`, нет доступа к значениям;

- `CROSS` 

  > — декартово произведение двух таблиц целиком без указания ключевых колонок, секция с `ON/USING` явно не пишется;

- `EXCLUSION` 

  > — обе стороны минус пересечение.

Простой пример запроса с объединением таблиц приведен ниже.

`SELECT
    sa.title AS season_title,
    sr.title AS series_title,
    sr.series_id, sa.season_id 
FROM seasons AS sa
INNER JOIN series AS sr ON sa.series_id = sr.series_id 
WHERE sa.season_id = 1
ORDER BY sr.series_id;`

> `SELECT
>     seasons.title AS season_title,
>     series.title AS series_title,
>     series.series_id, seasons.season_id 
> FROM seasons
> INNER JOIN series ON seasons.series_id = series.series_id 
> WHERE seasons.season_id = 1
> ORDER BY series.series_id;`
>
> Так стало (названия таблиц, из которых тыбзились данные, били заменены):

Этот запрос извлекает из таблиц `series` и `seasons` сведения о первых сезонах всех сериалов и выводит объединённые данные в результирующей таблице.

**Задание 7:** напишите запрос, который выводит таблицу, содержащую название сериала IT Crowd и названия всех его эпизодов (то есть, каждая строка итоговой таблице должна содержать название сериала и название отдельного эпизода).

> `SELECT 
>     sr.title AS series_title, 
>     ep.title AS episode_title, 
>     ep.season_id,     
>     ep.episode_id 
> FROM 
>     series AS sr 
> INNER JOIN 
>     episodes AS ep 
> ON sr.series_id = ep.series_id 
> WHERE sr.series_id = 1 
> ORDER BY 
>     ep.season_id,     
>     ep.episode_id 
> ; `

# План запроса

Когда вы обращаетесь к БД, оптимизатор запросов YDB пытается составить наилучший, по его мнению, план выполнения запроса.

Чтобы оптимизировать свои запросы к БД с точки зрения скорости их выполнения (и/или стоимости, что актуально для бессерверного режима YDB), нужно получить и проанализировать этот план. Вы можете это сделать через консоль управления или с помощью YDB CLI.

Давайте разберём план запроса, который мы использовали на прошлом уроке в качестве примера объединения таблиц.

`SELECT 
    sa.title AS season_title, 
    sr.title AS series_title, 
    sr.series_id, sa.season_id 
FROM seasons AS sa 
INNER JOIN series AS sr ON sa.series_id = sr.series_id 
WHERE sa.season_id = 1 `

Войдите в редактор SQL вашей БД и вставьте в поле ввода текст запроса. Нажмите на стрелку справа от кнопки **Выполнить** и в выпадающем меню выберите опцию **Explain**.

В результате внизу отобразится поле, содержащее план запроса.

`{
  "plan": {
    "meta": {
      "type": "script",
      "version": "0.2"
    },
    "queries": [
      {
        "tables": [
          {
            "name": "/ru-central1/b1glk1805em030s2ir60/etn9c1c7v3s2bc06lfm8/seasons",
            "reads": [
              {
                "columns": [
                  "season_id",
                  "series_id",
                  "title"
                ],
                "type": "FullScan",
                "scan_by": [
                  "series_id",
                  "season_id"
                ]
              }
            ]
          },
          {
            "name": "/ru-central1/b1glk1805em030s2ir60/etn9c1c7v3s2bc06lfm8/series",
            "reads": [
              {
                "columns": [
                  "series_id",
                  "title"
                ],
                "lookup_by": [
                  "series_id (expr)"
                ],
                "type": "MultiLookup"
              }
            ]
          }
        ]
      }
    ]
  }
}`

Основная секция (`tables`) плана запроса содержит информацию об обращениях к таблицам. Операция чтения описываются в разделе `reads`, а операции записи — в разделе `writes` (в этом плане запроса данный раздел отсутствует).

Ключевой характеристикой любого обращения к таблице является его тип.

**Типы чтения:**

- `FullScan` — полное сканирование таблицы, читаются все записи на всех шардах;
- `Scan` — читается определённый диапазон записей;
- `Lookup` — чтение по ключу или префиксу ключа;
- `MultiLookup` — множественные чтения по ключу или префиксу ключа (такой тип обращения возможен, например при выполнении инструкций `JOIN`).

**Типы записи:**

- `Upsert` — добавление одной записи;
- `MultiUpsert` — добавление нескольких записей;
- `Erase` — единичное удаление по ключу;
- `MultiErase` — множественные удаления.

Рассмотрим план запроса из нашего примера.

Параметр `lookup_by` показывает, по каким колонкам (ключу или префиксу ключа) выполняется чтение. Параметр `scan_by` показывает, по каким колонкам выполняется `scan`, то есть чтение всех записей в определённом диапазоне значений. В `columns` перечислены колонки, значения которых будут считываться из таблицы.

Из плана запроса следует, что для таблицы `seasons` будет выполнен `FullScan`, а для таблицы `series` — множественные чтения (тип обращения `MultiLookup`) по ключу `series_id` (`lookup_by`). Это говорит нам о том, что данный запрос составлен не лучшим образом. Тип чтения `FullScan` означает, что для выполнения запроса потребуется полностью прочитать всю таблицу. Если таблица большая, то такой запрос приведет к избыточному росту нагрузки на БД и задержкам, а в режиме serverless — еще и к повышенным расходам.

# Диагностика и мониторинг

Когда вы работаете с БД, важно отслеживать, как она справляется с нагрузкой. YDB предоставляет пользователям необходимые для этого инструменты мониторинга и диагностики.

В разделе **Мониторинг** консоли управления вы найдете дашборды, на которых приведены графики изменения метрик, характеризующих потребление ресурсов (CPU, оперативной памяти и дискового пространства) и время задержки транзакций (например, задержки операций чтения и операций записи на сервере или на клиенте БД).

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/35/ydb_6_1.png)

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/35/ydb_6_2.png)

В разделе **Диагностика** предоставлена возможность доступа к «системным» (то есть, специальным служебным) таблицам, содержащим детализированную информацию о работе БД. Нужные сведения извлекаются из системных таблиц с помощью YQL запросов.

В этом разделе вы можете получить информацию о размерах партиций таблиц и нагрузке на них; выяснить, какие запросы выполняются дольше других, больше всего нагружают CPU или приводят к чтению наибольшего объема данных. Для наиболее характерных вопросов о работе БД нужные YQL запросы уже составлены. Вам остается только их запустить и проанализировать полученные результаты.

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/35/ydb_6_3.png)

Давайте посмотрим, как это работает. Откройте раздел **Диагностика** в консоли управления и кликните на пункт «Топ таблиц по размеру».

Вы перейдете в раздел **Навигация**, где в SQL-редакторе увидите заполненное поле ввода с запросом к служебной таблице `partition_stats`, в которой хранится информация об отдельных партициях всех таблиц БД.

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/35/ydb_6_4.png)

Нажмите кнопку **Выполнить**. YDB выведет информацию об имеющихся в БД таблицах, их размере, суммарном числе строк и количестве партиций, а также суммарном потреблении процессора.

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/35/ydb_6_5.png)

Эти сведения могут помочь вам улучшить работу БД или предвосхитить возможные проблемы. Например, если основная нагрузка (потребление процессора) приходится на одну из таблиц, то впору задуматься о ее правильном партиционировании и/или оптимизации идущих к ней запросов.

Подробная информация о системных таблицах и о том, какие данные в них хранятся, [приведена в документации](https://ydb.tech/ru/docs/troubleshooting/system_views_db).

Пользуйтесь инструментами диагностики и мониторинга, это поможет вашей БД работать быстро и надежно.

# Создание резервных копий

YDB создает резервные копии вашей БД автоматически. При этом регламент резервного копирования вы можете настраивать самостоятельно .

Зайдите в раздел **Резервные копии** в консоли управления и выберите вкладку **Расписание**. По умолчанию резервное копирование выполняется ежедневно в 17:00, а срок хранения резервных копий (TTL, time-to-live) составляет два дня.

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/38/01.png)

Чтобы изменить эти параметры нажмите **…** и выберите **Редактировать**. В открывшемся окне вы можете выбрать периодичность создания резервных копий (ежедневно или еженедельно), время начала резервного копирования, а также срок хранения.

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/38/02.png)

YDB также позволяет создавать резервные копии БД вручную как непосредственно в хранилище данных, так и в виде csv-файлов в файловой системе (например на вашем компьютере) или S3-совместимом объектном хранилище (например в Yandex Object Storage).

Создавать резервные копии в хранилище данных и восстанавливать их можно через консоль управления Yandex Cloud. Резервное копирование в файловую систему или объектное хранилище выполняется с помощью консольного клиента YDB. О том, как это сделать, подробно [рассказано в документации](https://cloud.yandex.ru/docs/ydb/maintenance/backup_and_recovery).

Чтобы выполнить резервное копирование вашей БД вручную через консоль управления, зайдите в нее и выберите раздел **Резервные копии**. Нажмите на кнопку **Создать резервную копию**.

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/38/03.png)

В появившемся окне задайте имя резервной копии и выберите время запуска — **Немедленно**. Чтобы создаваемая резервная копия была удалена автоматически, выберите соответствующую опцию и укажите время хранения в днях. Запустите резервное копирование, нажав на кнопку **Создать**.

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/38/04.png)

Когда процесс завершится, резервная копия сменит статус с **Creating** на **Ready**. Статус создания и восстановления резервных копий также можно отслеживать в разделе **Операции**.

Восстанавливать резервную копию БД удобно в отдельную директорию. Создайте директорию `restore` для восстанавливаемых данных (это делается в разделе **Навигация**).

Нажмите **…** справа от созданной резервной копии и выберите **Восстановить**. Для восстановления данных укажите текущую БД и созданную директорию `restore`. Нажмите кнопку **Восстановить**.

![image](https://code.s3.yandex.net/Cloud/CloudEngineer/DB/38/05.png)

Когда операция завершится, зайдите в директорию `restore` в разделе **Навигация** и убедитесь, что в ней появились восстановленные таблицы с данными.

